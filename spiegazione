Ok, te lo spiego “da progetto”, concreto e senza fronzoli. L’idea è spostare tutta la logica di comunicazione dal `Process` a un vero middleware: una classe `Com` (communicator) che gestisce messaggi, orologi logici, sincronizzazioni e servizi distribuiti. Qui sotto cosa devi costruire, come strutturarlo e gli algoritmi minimi da implementare.

# Cosa devi consegnare

* Codice (Java o altro) del middleware.
* JavaDoc/Docstring di **tutte** le API esposte.
* Un esempio d’uso (tipo mini-gioco dei dadi) che usa **solo** le API del communicator.
* (Opzionale avanzato) Heartbeat + rinumerazione dinamica se un processo muore.

---

# Architettura proposta (pacchetti/classi)

## Modello dei messaggi

* `abstract class Message`

  * campi comuni: `payload:Object`, `lamportStamp:long`, `from:int`, `to:Integer|null`, `type:MessageType`, `isSystem:boolean`
  * `enum MessageType { USER, TOKEN, SYNC, HEARTBEAT, ACK, NAMESERVICE, ... }`
* Eventuali sottoclassi: `UserMessage`, `TokenMessage`, `SyncMessage`, `HeartbeatMessage`…

> Regola: **solo** i messaggi `USER` influenzano l’orologio di Lamport. `TOKEN`, `HEARTBEAT`, `SYNC` ecc. **no**.

## Orologio di Lamport

* `class LamportClock`

  * `private long time`
  * `private final Semaphore lock = new Semaphore(1)`
  * `long inc()` — usata da `Com.inc_clock()` (richiamabile dal processo)
  * `long onSend()` — `lock`, `time++`, return stamp
  * `void onReceive(long remote)` — `lock`, `time = max(time, remote) + 1`
* Tutte le modifiche passano attraverso il **semaforo** per evitare race tra `Process` e `Com`.

## Mailbox (B.a.L.)

* `BlockingQueue<Message> inbox = new LinkedBlockingQueue<>()`
* Il communicator deposita qui **tutti** i messaggi asincroni destinati al processo.
* Il processo “pesca” quando vuole (metodi tipo `poll()`/`take()` esposti da `Com`).

## Transport astratto

* Interfaccia `Transport` (socket/TCP, MPI, RMI… a scelta)
  * `void send(int dest, Message m)`
  * `void broadcast(Set<Integer> peers, Message m)`
  * `void start(Consumer<Message> onMessage)` — thread di ricezione che chiama `onMessage`
* `Com` non usa variabili di classe/statiche per identificazione: prende tutto via costruttore o discovery.

## Naming/Numbering (assegnazione ID)

* Obbligo: numerazione **automatica**, consecutiva da 0.
* Possibili strategie:

  1. **NameServer** (processo bootstrap) che assegna ID in ordine di arrivo.
  2. **Elezione + registro distribuito** (più complesso).
* API minime nel `Com`:

  * `int getId()`
  * `int getWorldSize()`
  * `List<Integer> getPeers()`
* Vietate statiche: memorizzi stato nel communicator e/o nel registry.

## Heartbeat + rinumerazione (estensione)

* Ogni `T` secondi `Com` invia `HeartbeatMessage` (system) a tutti.
* Un watcher thread mantiene `lastSeen[peer]`. Se scade un timeout ⇒ peer “morto”.
* Rinumerazione: ricalcolo di ID consecutivi per i vivi, propagato con una fase di **stop-the-world** (barriera + mappa vecchi→nuovi ID), poi **resume**. (Documenta bene le implicazioni!)

---

# API del Communicator (`Com`)

### Inizializzazione

```java
public final class Com {
  public Com(Transport t, NameService ns) { ... } // ottiene id, peers
  public int id();
  public int size();
  public long inc_clock(); // opzionale per il processo
  public Message take();   // blocca finché c’è un msg in mailbox
  public Message poll(long timeout, TimeUnit u);
}
```

### Comunicazione asincrona (non bloccante per il mittente)

```java
public void broadcast(Object o);            // mette o nelle B.a.L. degli altri
public void sendTo(Object o, int dest);     // mette o nella B.a.L. di dest
```

* Implementazione:

  * prima di spedire un **USER**: `stamp = clock.onSend()`, inserisci nello `Message.lamportStamp`.
  * alla ricezione: se `USER`, `clock.onReceive(msg.stamp)` e poi `inbox.put(msg)`.

### Comunicazione sincrona (bloccante)

```java
public void broadcastSync(Object o, int from);
public void sendToSync(Object o, int dest);       // mittente blocca finché dest conferma
public void recvFromSync(int from, Consumer<Object> handler); // blocca in attesa
```

* Pattern tipico:

  * `sendToSync`: manda `USER` + attende `ACK` da `dest`.
  * `recvFromSync`: blocca finché riceve `USER` da `from`, consegna al `handler`, invia `ACK`.
  * `broadcastSync(o, from)`: se `id()==from`, invia a tutti e attende tutti gli `ACK`; altrimenti blocca finché riceve `o` da `from`.

### Sezione critica distribuita (mutua esclusione)

* Richieste: `requestSC()` e `releaseSC()`, **bloccanti**, niente busy-wait.
* Metodo **semplice** richiesto: **token su anello (ring)** **gestito da un thread terzo** interno a `Com`.

  * Thread `TokenManager` mantiene:

    * `boolean wantSC`, `Semaphore scPermit(0)`
    * `volatile boolean hasToken`
  * `requestSC()`:

    * set `wantSC = true`
    * blocca su `scPermit.acquire()` finché `hasToken == true`
  * `releaseSC()`:

    * `wantSC = false`
    * passa il token al prossimo peer nell’anello (send `TokenMessage`), `hasToken=false`
  * Ricezione `TokenMessage`:

    * **non** tocca l’orologio (system)
    * `hasToken = true`
    * se `wantSC` ⇒ `scPermit.release()`, altrimenti inoltra al prossimo.

### Barriera di sincronizzazione

```java
public void synchronize(); // blocca finché tutti hanno invocato
```

* Implementazione semplice:

  * Fase 1: ogni processo invia `SYNC` a tutti.
  * Attende `SYNC` da tutti gli altri ⇒ poi rilascia un `barrierPermit`.
  * (Oppure albero/log N, ma non è necessario.)

---

# Thread nel Communicator

* `ReceiverThread` del `Transport`: deserializza e passa a `onMessage`.
* `TokenManagerThread`: gestisce token ring e SC.
* `HeartbeatThread` (estensione): invia heartbeat e controlla timeouts.
* Nessuna busy-wait: usa `BlockingQueue`, `Semaphore`, `CountDownLatch`.

---

# Algoritmi (riassunto operativo)

## Invio asincrono USER

1. `stamp = clock.onSend()`
2. `msg = new UserMessage(o, stamp, from=id, to=dest)`
3. `transport.send(dest, msg)`

## Ricezione USER

1. `clock.onReceive(msg.stamp)`
2. `inbox.put(msg)` (ora il processo può “pescare” quando vuole)

## `broadcastSync(o, from)`

* Se `id==from`: invia a tutti (`USER`) + crea `CountDownLatch(size-1)` per ACK; attende latch zero.
* Se `id!=from`: `recvFromSync(from, handler)`; dopo `handler.accept(o)`, manda `ACK`.

## Token ring SC

* Token circola su anello `(id+1)%size`.
* `requestSC()` blocca finché `hasToken==true`, poi entra in SC.
* `releaseSC()` passa il token al prossimo (se non lo vuole subito).

## Barriera

* `synchronize()`: invia `SYNC` a tutti; attende `SYNC` da tutti; ritorna.

## Numerazione

* All’avvio `Com` contatta `NameService` → riceve `id` e `peers`.
* `NameService` gestisce array `[0..N-1]` senza buchi.
* (Estensione) Se un peer muore (heartbeat timeout), il registry ricalcola mappa vecchi→nuovi ID e la notifica; i `Com` si aggiornano in una barriera.

---

# Contratti (blocking / no busy-wait)

* Tutti i servizi marcati “bloccanti” devono usare primitive di sincronizzazione (`Semaphore`, `CountDownLatch`, `BlockingQueue`), **mai** loop a vuoto.
* I metodi asincroni **non** bloccano il chiamante (solo tempo di enqueue/send).


---

# Checklist di conformità ai requisiti

* [x] Tutte le **API di comunicazione** sono in `Com`, non in `Process`.
* [x] **LamportClock** con **semaforo**; `inc_clock()` esposto al processo.
* [x] **Solo** messaggi **USER** toccano l’orologio.
* [x] **Mailbox** B.a.L. per i messaggi asincroni.
* [x] **broadcast/sendTo** asincroni.
* [x] **broadcastSync/sendToSync/recvFromSync** bloccanti con ACK/latch.
* [x] **requestSC/releaseSC** con **token ring** gestito da **thread terzo**; token = system (no Lamport).
* [x] **synchronize()** (barriera).
* [x] **Numerazione automatica** senza variabili di classe; opzionale **heartbeat + rinumerazione**.
* [x] Niente **busy-wait**: solo mutex/semafori/queue.

Se vuoi, posso fornirti un **scheletro Java** pronto (interfacce + classi vuote + Javadoc) su cui attaccare i dettagli del tuo transport.
