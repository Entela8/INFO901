# ğŸ§  Objectif du TP

CrÃ©er un **middleware (intergiciel)** appelÃ© `Com` qui :

* sâ€™intercale entre les processus utilisateurs
* gÃ¨re toute la **communication inter-processus** (async, sync)
* garantit une **horloge de Lamport** cohÃ©rente
* fournit des outils de **coordination distribuÃ©e** :

  * **section critique** avec un **jeton sur anneau**
  * **barriÃ¨re de synchronisation**
  * **numÃ©rotation automatique des processus**
  * **heartbeats + dÃ©tection de pannes + renumÃ©rotation**

Autrement dit : au lieu que les `Process` communiquent directement entre eux, ils passent **exclusivement** par leur `Com` local.

---

# âš™ï¸ Architecture rÃ©alisÃ©e


---

## ğŸšŒ `Bus`

**But** : simuler un **bus mÃ©moire partagÃ©** entre processus.

* Chaque `Com` sâ€™y **enregistre** (`join`) et reÃ§oit un **id logique unique**.
* GÃ¨re lâ€™**ordre des processus vivants** dans une liste `_directory`
* Permet Ã  `Com` de :

  * envoyer Ã  tous (`broadcast`)
  * envoyer Ã  un destinataire prÃ©cis (`sendto`)
* Fait circuler les **heartbeats** pour dÃ©tecter les processus morts
* Fait la **renumÃ©rotation automatique** quand un nÅ“ud meurt
* Fait la **barriÃ¨re globale** (`barrier_arrive`)

ğŸ“Œ TrÃ¨s important : ce `Bus` est une **instance**, donc il nâ€™y a **aucune variable de classe globale** dans `Com` (comme le demande le sujet).

---

## ğŸ“¬ `Com`

Câ€™est le **communicateur** que chaque `Process` instancie.
Il fournit toute lâ€™**API distribuÃ©e** exigÃ©e par le sujet :

---

### ğŸ•’ Horloge de Lamport

* `self.clock` est protÃ©gÃ©e par `self.clock_lock`
* Chaque envoi (`broadcast`, `sendTo`) fait un `inc_clock()`
* Chaque rÃ©ception met Ã  jour `clock = max(local, reÃ§u)+1`

---

### ğŸ“¦ BoÃ®te aux lettres (BAL)

* Chaque message reÃ§u est dÃ©posÃ© dans `self.mailbox`
* Le processus peut lire avec `receive()`

---

### ğŸ“¡ Communication asynchrone

* `broadcast(payload)` : envoie Ã  tous
* `sendTo(payload, dest)` : envoie Ã  un destinataire
* gÃ¨re automatiquement horloge + dÃ©pÃ´t BAL

---

### â›“ Communication synchrone

* `broadcastSync(payload, from_id)` : bloque jusquâ€™Ã  ce que tout le monde ait accusÃ© rÃ©ception
* `sendToSync(payload, dest)` / `recvFromSync(from_id)` : blocage mutuel
* implÃ©mentÃ© avec un systÃ¨me de **ACKs** et dâ€™`Event`

---

### ğŸ§± BarriÃ¨re de synchronisation

* `synchronize()` bloque jusquâ€™Ã  ce que **tous** les processus lâ€™appellent
* gÃ©rÃ© par `Bus.barrier_arrive` qui libÃ¨re tout le monde en mÃªme temps

---

### ğŸ” Section critique distribuÃ©e

* `requestSC()` / `releaseSC()`
* implÃ©mentÃ© avec un **jeton** (`Token`) qui tourne en anneau logique
* `requestSC()` bloque tant que le processus nâ€™a pas reÃ§u le jeton
* les messages de type `Token` **nâ€™impactent pas lâ€™horloge de Lamport** (important)

---

### â¤ï¸ Heartbeats et renumÃ©rotation

* chaque `Com` envoie pÃ©riodiquement un heartbeat Ã  `Bus`
* si un `Com` ne donne plus signe de vie, `Bus.check_timeouts()` le considÃ¨re mort
* `Bus` **retire ce processus** et **recalcule les IDs** de tous les survivants

---

## ğŸ’Œ Types de messages

Dans `Message.py` (et sous-classes) :

* `Message` de base (`kind`, `payload`, `lamport`, `sender`)
* `BroadcastMessage`, `MessageTo` â†’ messages applicatifs (USER)
* `AckMessage` â†’ pour la comm synchrone
* `Token` â†’ pour la SC
* `BarrierMessage` â†’ pour la barriÃ¨re (optionnel)
* `MsgKind` enum pour les distinguer

ğŸ“Œ Les messages systÃ¨me (`TOKEN`, `ACK`, `RENUMBER`, `BARRIER`) **ne mettent pas Ã  jour lâ€™horloge**.

---

## ğŸ§ª Process et Launcher

* `Process` crÃ©e un `Com` et appelle ses mÃ©thodes pour faire un scÃ©nario :
  `broadcast`, `sendTo`, `broadcastSync`, `sendToSync`, `synchronize`, `requestSC`, etc.
* `Launcher` crÃ©e plusieurs `Process` dans des threads et les lance ensemble

---

# ğŸ§© Pourquoi Ã§a respecte le sujet

âœ… Horloge de Lamport protÃ©gÃ©e
âœ… BAL pour chaque processus
âœ… Communication asynchrone et synchrone
âœ… Section critique avec jeton (messages systÃ¨me ignorent lâ€™horloge)
âœ… BarriÃ¨re `synchronize()`
âœ… NumÃ©rotation automatique **sans variable de classe**
âœ… Heartbeats + renumÃ©rotation dynamique
âœ… JavaDoc/README facilement ajoutables + exemple dâ€™utilisation (`Launcher`)

---


Tu as maintenant un **middleware distribuÃ© complet** conforme au sujet, organisÃ© proprement :

```
Bus.py
Com.py
Message.py / BroadcastMessage.py / MessageTo.py / Token.py / Synchronize.py
Process.py
Launcher.py
```

Chaque `Process` passe par son `Com`, qui passe par le `Bus`, qui distribue les messages aux autres `Com`.

---

Si tu veux, je peux maintenant :

* ğŸ“ tâ€™Ã©crire un **README clair** Ã  rendre avec ton code
* ğŸ² ou te coder un **exemple dâ€™application** (jeu de dÃ©s multi-processus)

Veux-tu que je fasse Ã§a ?
